1. Что такое первичный ключ?
Для индентификации записей в БД (для обеспечения их уникальности).
Первичный ключ: набор определенных признаков, уникальных для каждой записи. Обозначается первичный ключ, как primary key.
Primary key (PK) очень важен для каждой таблицы. Поясню почему.
Primary key не позволяет создавать одинаковых записей (строк) в таблице;
Обычно первичный ключ – числовое значение. Но он также может быть и любым другим типом данных.
Не является обычной практикой использование строки в качестве первичного ключа (строка – фрагмент текста), но теоретически и практически это возможно.
Составные первичные ключи.
Часто первичный ключ состоит из одного поля, но он может быть и комбинацией нескольких столбцов, например, двух (трех, четырех…).
Но вы помните, что первичный ключ всегда уникален, а значит нужно, чтобы комбинация n-го количества полей, в данном случае 2-х, была уникальна.

2. Что такое внешний ключ?
foreign key - FK
PK обеспечивают логическую связь между таблицами одной базы данных (для реляционных БД).
Записи в таблицах могут быть связаны для того, чтобы установить отношения между ними. Проектирование базы данных –
это в частности определение связей между таблицами (и сущнастями, которые они определяют)
Один-ко-многим.
Например Клиенты и Заказы имеют связь (состоят в отношениях) один-ко-многим потому, что один клиент может иметь много заказов,
но каждый конкретный заказ (их множество) оформлен только одним клиентом, т.е. может иметь только одного клиента.
Для связи один-ко-многим необходимо две отдельные таблицы. Одна для клиентов, другая для заказов.
При этом каждый заказ и клиент (таблица) имеет поле PK - для однозначной идентификации сущности,
но заказ так же имет поле FK - customer_id, которое сзвязывает эти таблицы

3. Что такое нормализация БД?
Нормализация — это процесс организации данных в БД, включающий создание таблиц и установление отношений между ними в соответствии с правилами,
которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.
Избыточность данных приводит к непродуктивному расходованию свободного места на диске и затрудняет обслуживание баз данных.
Например, если данные, хранящиеся в нескольких местах, потребуется изменить, в них придется внести одни и те же изменения во всех этих местах.
Изменение адреса клиента гораздо легче реализовать, если в базе данных эти сведения хранятся только в таблице Customers и нигде больше.
Что такое «несогласованные зависимости»? Пользователь, которому нужно узнать, например, адрес определенного клиента,
вполне обоснованно будет искать его в таблице Customers (клиенты), но искать в ней сведения о зарплате сотрудника,
который работает с этим клиентом, не имеет смысла. Зарплата сотрудника связана с сотрудником (зависит от него),
поэтому эти сведения следует хранить в таблице Employees (сотрудники).
Несогласованные зависимости могут затруднять доступ к данным, так как путь к данным при этом может отсутствовать или быть неправильным.
Существует несколько правил нормализации баз данных. Каждое правило называется «нормальной формой».
Если выполняется первое правило, говорят, что база данных представлена в «первой нормальной форме».
Если выполняются три первых правила, считается, что база данных представлена в «третьей нормальной форме».
Есть и другие уровни нормализации, однако для большинства приложений достаточно нормализовать базы данных до третьей нормальной формы.
Как и в случае со многими другими формальными правилами и спецификациями, обеспечить полное соответствие реальным ситуациям не всегда возможно.
Как правило, для выполнения нормализации приходится создавать дополнительные таблицы, и некоторые клиенты считают это нежелательным.
Собираясь нарушить одно из первых трех правил нормализации, убедитесь в том, что в приложении учтены все связанные с этим проблемы,
такие как избыточность данных и несогласованные зависимости.
Первая нормальная форма
Устраните повторяющиеся группы в отдельных таблицах.
Создайте отдельную таблицу для каждого набора связанных данных.
Идентифицируйте каждый набор связанных данных с помощью первичного ключа.
Не используйте несколько полей в одной таблице для хранения похожих данных.
Например, для слежения за товаром, который закупается у двух разных поставщиков, можно создать запись с полями, определяющими код первого поставщика и код второго поставщика.
Что произойдет при добавлении третьего поставщика? Добавление третьего поля нежелательно, так как для этого нужно изменять программу и таблицу,
поэтому данный способ плохо адаптируется к динамическому изменению числа поставщиков.
Вместо этого можно поместить все сведения о поставщиках в отдельную таблицу Vendors (поставщики) и связать товары с
поставщиками с помощью кодов товаров или поставщиков с товарами с помощью кодов поставщиков.
Вторая нормальная форма
Создайте отдельные таблицы для наборов значений, относящихся к нескольким записям.
Свяжите эти таблицы с помощью внешнего ключа.
Записи могут зависеть только от первичного ключа таблицы (составного ключа, если необходимо).
Возьмем для примера адрес клиента в системе бухгалтерского учета.
Этот адрес необходим не только таблице Customers, но и таблицам Orders, Shipping, Invoices, Accounts Receivable и Collections.
Вместо того чтобы хранить адрес клиента как отдельный элемент в каждой из этих таблиц, храните его в одном месте: или в таблице Customers, или в отдельной таблице Addresses.
Третья нормальная форма
Устраните поля, не зависящие от ключа.
Значения, входящие в запись и не являющиеся частью ключа этой записи, не принадлежат таблице.
Если содержимое группы полей может относиться более чем к одной записи в таблице, подумайте о том, не поместить ли эти поля в отдельную таблицу.
Например, в таблицу Employee Recruitment (наем сотрудников) можно включить адрес кандидата и название университета,
в котором он получил образование. Однако для организации групповой почтовой рассылки необходим полный список университетов.
Если сведения об университетах будут храниться в таблице Candidates, составить список университетов при отсутствии кандидатов не получится.
Таким образом, создайте вместо этого отдельную таблицу Universities и свяжите ее с таблицей Candidates при помощи ключа — кода университета.
Исключение. Выполнять нормализацию баз данных до третьей нормальной формы теоретически желательно, но не всегда практично.
Например, для устранения всех возможных зависимостей между полями таблицы Customers придется создать отдельные таблицы для хранения сведений о городах,
почтовых индексах, торговых представителях, категориях клиентов и любых других сведений, которые могут дублироваться в нескольких записях.
С теоретической точки зрения нормализация желательна. Однако значительное увеличение числа маленьких таблиц может привести
к снижению производительности СУБД или исчерпанию памяти и числа дескрипторов открытых файлов.
Выполнять нормализацию до третьей нормальной формы может быть целесообразно только для часто изменяемых данных.
Если при этом сохранятся зависимые поля, спроектируйте приложение так, чтобы при изменении одного из этих полей пользователь должен был проверить все связанные поля.

4. Что такое денормализация БД? Для чего она нужна?
Это намеренное нарушение нормальных форм, для увеличения производительности.
В запросах к полностью нормализованной базе нередко приходится соединять до десятка, а то и больше, таблиц.
А каждое соединение — операция весьма ресурсоемкая. Как следствие, такие запросы кушают ресурсы сервера и выполняются медленно.
В такой ситуации может помочь:
- денормализация путем сокращения количества таблиц. Лучше объединять в одну несколько таблиц, имеющих небольшой размер,
содержащих редко изменяемую (как часто говорят, условно-постоянную, или нормативно-справочную) информацию, причем информацию, по смыслу тесно связанную между собой.
В общем случае, если в большом количестве запросов требуется объединять более пяти или шести таблиц, следует рассмотреть вариант денормализации базы данных.
- Денормализация путём ввода дополнительного поля в одну из таблиц. При этом появляется избыточность данных, требуются дополнительные действия для сохранения целостности БД.


5. Что такое кластерный и некластерный индекс?
6. Какие типы соединений (join) таблиц существуют? В чем их разница?
7. Что такое SQL курсор?
8. Опишите шаги по созданию и использованию курсора?
10. Что такое транзакция?
11. Что такое триггер? (Какие типы триггеров вы знаете?)
12. В чем разница между WHERE и HAVING?
13. Что такое подзапрос (sub-query)?

14. Что такое union?

15. Что такое group by

17. Что такое хранимые процедуры?

18. Что такое view(Представление)?

19. Опишите процесс создания запроса через JDBC.

20. Для чего используется конструкция try-with-resources.