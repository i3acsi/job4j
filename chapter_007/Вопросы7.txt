1. Что такое первичный ключ?
Для индентификации записей в БД (для обеспечения их уникальности).
Первичный ключ: набор определенных признаков, уникальных для каждой записи. Обозначается первичный ключ, как primary key.
Primary key (PK) очень важен для каждой таблицы. Поясню почему.
Primary key не позволяет создавать одинаковых записей (строк) в таблице;
Обычно первичный ключ – числовое значение. Но он также может быть и любым другим типом данных.
Не является обычной практикой использование строки в качестве первичного ключа (строка – фрагмент текста), но теоретически и практически это возможно.
Составные первичные ключи.
Часто первичный ключ состоит из одного поля, но он может быть и комбинацией нескольких столбцов, например, двух (трех, четырех…).
Но вы помните, что первичный ключ всегда уникален, а значит нужно, чтобы комбинация n-го количества полей, в данном случае 2-х, была уникальна.

2. Что такое внешний ключ?
foreign key - FK
PK обеспечивают логическую связь между таблицами одной базы данных (для реляционных БД).
Записи в таблицах могут быть связаны для того, чтобы установить отношения между ними. Проектирование базы данных –
это в частности определение связей между таблицами (и сущнастями, которые они определяют)
Один-ко-многим.
Например Клиенты и Заказы имеют связь (состоят в отношениях) один-ко-многим потому, что один клиент может иметь много заказов,
но каждый конкретный заказ (их множество) оформлен только одним клиентом, т.е. может иметь только одного клиента.
Для связи один-ко-многим необходимо две отдельные таблицы. Одна для клиентов, другая для заказов.
При этом каждый заказ и клиент (таблица) имеет поле PK - для однозначной идентификации сущности,
но заказ так же имет поле FK - customer_id, которое сзвязывает эти таблицы

3. Что такое нормализация БД?
Нормализация — это процесс организации данных в БД, включающий создание таблиц и установление отношений между ними в соответствии с правилами,
которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.
Избыточность данных приводит к непродуктивному расходованию свободного места на диске и затрудняет обслуживание баз данных.
Например, если данные, хранящиеся в нескольких местах, потребуется изменить, в них придется внести одни и те же изменения во всех этих местах.
Изменение адреса клиента гораздо легче реализовать, если в базе данных эти сведения хранятся только в таблице Customers и нигде больше.
Что такое «несогласованные зависимости»? Пользователь, которому нужно узнать, например, адрес определенного клиента,
вполне обоснованно будет искать его в таблице Customers (клиенты), но искать в ней сведения о зарплате сотрудника,
который работает с этим клиентом, не имеет смысла. Зарплата сотрудника связана с сотрудником (зависит от него),
поэтому эти сведения следует хранить в таблице Employees (сотрудники).
Несогласованные зависимости могут затруднять доступ к данным, так как путь к данным при этом может отсутствовать или быть неправильным.
Существует несколько правил нормализации баз данных. Каждое правило называется «нормальной формой».
Если выполняется первое правило, говорят, что база данных представлена в «первой нормальной форме».
Если выполняются три первых правила, считается, что база данных представлена в «третьей нормальной форме».
Есть и другие уровни нормализации, однако для большинства приложений достаточно нормализовать базы данных до третьей нормальной формы.
Как и в случае со многими другими формальными правилами и спецификациями, обеспечить полное соответствие реальным ситуациям не всегда возможно.
Как правило, для выполнения нормализации приходится создавать дополнительные таблицы, и некоторые клиенты считают это нежелательным.
Собираясь нарушить одно из первых трех правил нормализации, убедитесь в том, что в приложении учтены все связанные с этим проблемы,
такие как избыточность данных и несогласованные зависимости.
Первая нормальная форма (1NF) — нет повторяющихся групп в строках
Вторая нормальная форма (2NF) — каждое неключевое (поддерживающее) значение столбца зависит от всего первичного ключа
Третья нормальная форма (3NF) — каждое неключевое значение зависит только от первичного ключа и не имеет зависимости от другого неключевого значения столбца

4. Что такое денормализация БД? Для чего она нужна?
Это намеренное нарушение нормальных форм, для увеличения производительности.
В запросах к полностью нормализованной базе нередко приходится соединять до десятка, а то и больше, таблиц.
А каждое соединение — операция весьма ресурсоемкая. Как следствие, такие запросы кушают ресурсы сервера и выполняются медленно.
В такой ситуации может помочь:
- денормализация путем сокращения количества таблиц. Лучше объединять в одну несколько таблиц, имеющих небольшой размер,
содержащих редко изменяемую (как часто говорят, условно-постоянную, или нормативно-справочную) информацию, причем информацию, по смыслу тесно связанную между собой.
В общем случае, если в большом количестве запросов требуется объединять более пяти или шести таблиц, следует рассмотреть вариант денормализации базы данных.
- Денормализация путём ввода дополнительного поля в одну из таблиц. При этом появляется избыточность данных, требуются дополнительные действия для сохранения целостности БД.


5. Что такое кластерный и некластерный индекс?
Индексы в общем — структуры данных, предназначенные в основном для ускорения доступа к данным.
Это вспомогательные структуры: любой индекс можно удалить и восстановить заново по информации в
таблице. Индексы служат также для поддержки некоторых ограничений целостности.
Несмотря на все различия между типами индексов (называемыми также методами доступа),
в конечном счете любой из них устанавливает соответствие между ключом
(например, значением проиндексированного столбца) и строками таблицы,
в которых этот ключ встречается.
В PG есть такие методы доступа btree, hash, gist, gin, spgist, brin, а так же fullscan
Строки идентифицируются с помощью TID (tuple id),
который состоит из номера блока файла и позиции строки внутри блока.
Тогда, зная ключ или некоторую информацию о нем, можно быстро прочитать те строки,
в которых может находиться интересующая нас информация, не просматривая всю таблицу полностью.
В любом случае поддержание индекса пораждает некоторый overhead (занимаемое место + увеличится время опреции изменения структуры данных) 
(обновление полей таблицы, по которым не создавались индексы, не приводит к перестроению индексов)

Чтобы методы доступа согласованно работали с БД, выделен общий механизм индексирования.
Его основной задачей является получение TID от метода доступа и работа с ними:
чтение данных из соответствующих версий строк таблицы;
выборка по отдельному TID, либо сразу по набору TID (с построением битовой карты);
проверка видимости версий строк для текущей транзакции с учетом уровня изоляции.

Механизм индексирования участвует в выполнении запросов;
он вызывается в соответствии с планом, построенным на этапе оптимизации.
Оптимизатор, перебирая и оценивая различные пути выполнения запроса,
должен понимать возможности всех методов доступа, которые потенциально можно применить. 
Механизм индексирования позволяет PostgreSQL одинаково работать с самыми разными методами доступа, учитывая их возможности.

Индексные записи B-дерева упакованы в страницы (или иными словами - блоки пмяти, как правило 8к).
В листовых страницах эти записи содержат индексируемые данные (ключи) и ссылки на строки
таблицы (TID-ы); во внутренних страницах каждая запись ссылается на дочернюю страницу индекса
и содержит минимальное значение ключа в этой странице. Данные в индексе упорядочены по неубыванию.

Если таблица достаточно большая и активно используется в режиме вставки, обновления или удаления,
это может оказаться недопустимым — изменяющие сеансы будут ожидать освобождения блокировки длительное время.
В этом случае можно воспользоваться параллельным созданием индекса.

6. Какие типы соединений (join) таблиц существуют? В чем их разница?
Существуют различные типы Joins доступные в SQL:

INNER JOIN – возвращает строки, когда совпадают в обеих таблицах.
LEFT JOIN – возвращает все строки из левой таблицы, даже если нет совпадений в таблице справа.
RIGHT JOIN – возвращает все строки из правой таблицы, даже если нет совпадений в левой таблице.
FULL JOIN – возвращает строки, когда есть совпадение в одной из таблиц.
SELF JOIN − используется для соединения таблицы с самой собой как если бы в таблице были две таблицы, временное переименование хотя бы одной таблицы в операторе SQL.

7. Что такое SQL курсор?
Курсор можно рассматривать как окно, в которое видно только часть из
множества результатов. Размер окна по умолчанию равен одной строке,
но настраивается. FETCH сдвигает окно (как правило, вниз, к концу
выборки) и возвращает видимое содержимое; MOVE только сдвигает
окно.
По окончанию работы открытый курсор закрывается, освобождая
ресурсы (SQL-команда CLOSE).
Курсоры позволяют работать с реляционными данными (множествами)
итеративно, строка за строкой. Иногда это удобно, но надо иметь в виду
накладные расходы на обращение к серверу за каждой новой порцией
данных.

Причины пользовать курсор : Курсор подразумевает итеративную обработку
                            полная выборка занимает слишком много памяти
                            нужна не вся выборка, но размер заранее неизвестен
                            способ отдать управление выборкой клиенту
                            действительно требуется построчная обработка (обычно нет)

(менее производителен, но можно делать какие-то действия над каждой строкой выборки, Поэтому курсоры рекомендуется использовать только в тех случаях,
когда описание требуемых действий через операции с множествами строк явно неэффективно или вообще невозможно.)

8. Опишите шаги по созданию и использованию курсора?

в SQL курсор объявлялся и открывался одновременно
командой DECLARE. В PL/pgSQL это два отдельных шага. Кроме того,
для доступа к курсорам используются так называемые курсорные
переменные, имеющие тип refcursor и, фактически, содержащие имя
курсора (причем если не указывать это имя явно, PL/pgSQL сам
позаботится о его уникальности).
Курсорную переменную можно объявить, не связывая ее с конкретным
запросом. Тогда при открытии курсора нужно будет указать запрос.
Другой вариант — уже при объявлении переменной указать запрос,
возможно с параметрами. При открытии курсора указываются уже
только фактические параметры.
Оба способа равноценны; какой использовать — дело вкуса.
Создадим таблицу:

=> CREATE TABLE t(id integer, s text);
CREATE TABLE
=> INSERT INTO t VALUES (1, 'Раз'), (2, 'Два'), (3, 'Три');
INSERT 0 3
Несвязанная переменная cur:

=> DO $$
DECLARE
    -- объявление переменной
    cur refcursor;
BEGIN
    -- связывание с запросом и открытие курсора
    OPEN cur FOR SELECT * FROM t;
END;
$$;
DO
Связанная переменная связывается с запросом уже при объявлении.

=> DO $$
DECLARE
    -- объявление и связывание переменной
    cur CURSOR FOR SELECT * FROM t;
BEGIN
    -- открытие курсора
    OPEN cur;
END;
$$;
DO
При этом переменная cur имеет тот же тип refcursor.

Связанная переменная может иметь параметры:

=> DO $$
DECLARE
    -- объявление и связывание переменной
    cur CURSOR(id integer) FOR SELECT * FROM t WHERE t.id = cur.id;
BEGIN
    -- открытие курсора с указанием фактических параметров
    OPEN cur(1);
END;
$$;
DO
Обратите внимание на устранение неоднозначности имен в этом и следующем примерах.

Переменные PL/pgSQL также являются (неявными) параметрами курсора.

=> DO $$
<<local>>
DECLARE
    id integer := 3;
    -- объявление и связывание переменной
    cur CURSOR FOR SELECT * FROM t WHERE t.id = local.id;
BEGIN
    id := 1;
    -- открытие курсора (значение id берется на этот момент)
    OPEN cur;
END;
$$;
DO

Чтение выполняется командой FETCH. Если нужно только сдвинуть "окно" курсора, то можно воспользоваться другой командой - MOVE.
https://edu.postgrespro.ru/dev1/dev1_13_plpgsql_cursors.html

10. Что такое транзакция?
Транзакция является единственной единицей работы. Сущность транзакции состоит в связывании нескольких шагов в одну операцию по принципу все-или-ничего.
Внутренние промежуточные состояния между шагами не видны для других конкурирующих транзакций и если во время выполнения транзакции случится ошибка,
которая помешает транзакции завершится, то в базе данных никаких изменений сделано не будет.
В PostgreSQL транзакция - это список команд SQL, которые находятся внутри блока, начинающегося командой BEGIN и заканчивающегося командой COMMIT.
В psql по умолчанию действует режим автофиксации:
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- и т.д. ....
COMMIT;
PostgreSQL фактически считает каждый оператор SQL запущенным в транзакции.
Если вы не указываете команду BEGIN, то каждый отдельный оператор имеет неявную команду BEGIN перед оператором и (при успешной отработке оператора) команду COMMIT после оператора.
Группа операторов заключаемая в блок между BEGIN и COMMIT иногда называется транзакционным блоком.
Возможно управлять операторами в транзакции и на более детализированном уровне с помощью "точек сохранения" (savepoints).
Точки сохранения позволяют выборочно отбрасывать части транзакции, в то же время выполняя остаток транзакции.
После того как вы зададите точку сохранения с помощью оператора SAVEPOINT, вы можете, если понадобится, откатить транзакцию до этой точки сохранения с помощью оператора ROLLBACK TO.
Все изменения базы данных внутри транзакции между точкой сохранения и местом откуда вызван откат теряются, но изменения, которые были сделаны до точки сохранения остаются.

11. Что такое триггер? (Какие типы триггеров вы знаете?)
Триггер определяет операцию, которая должна выполняться при наступлении некоторого события в базе данных.
Триггеры срабатывают при выполнении с таблицей команды SQL INSERT, UPDATE или DELETE.
В  PostgreSQL триггеры создаются на основе существующих функции, т.е. сначала  командой  CREATE (OR REPLACE) FUNCTION определяется  триггерная функция, затем на ее основе
командой CREATE TRIGGER  определяется собственно триггер.
•       CREATE TRIGGER триггер. В аргументе триггер указывается произвольное имя создаваемого триггера.
Имя может совпадать с именем триггера, уже существующего в базе данных   при условии, что этот триггер установлен для другой таблицы.
Кроме того, по аналогии с большинством других несистемных объектов баз данных, имя триггера (в сочетании с таблицей, для которой он устанавливается) должно быть уникальным
лишь в контексте базы данных, в которой он создается
•       { BEFORE | AFTER }. Ключевое слово BEFORE означает, что функция должна выполняться  перед попыткой выполнения операции,
включая все встроенные проверки ограничений данных, реализуемые при выполнении команд INSERT и DELETE. Ключевое слово AFTER означает,
что функция вызывается после завершения операции, приводящей в действие триггер.
•       { событие [ OR событие ... ] }. События SQL, поддерживаемые в PostgreSQL: INSERT, UPDATE или DELETE. При перечислении нескольких событий
в качестве разделителя используется ключевое слово OR.
•       ON таблица. Имя таблицы, модификация которой заданным событием приводит к срабатыванию триггера.
•       FOR EACH { ROW | STATEMENT }. Ключевое слово, следующее за конструкцией FOR EACH и определяющее количество вызовов функции при наступлении указанного события.
Ключевое слово ROW означает, что функция вызывается для каждой  модифицируемой записи.
Если функция должна вызываться всего один раз для всей команды, используется ключевое слово STATEMENT.
•       EXECUTE PROCEDURE функция ( аргументы ). Имя вызываемой функции с аргументами. На  практике аргументы  при вызове триггерных функций не используются.
Пример 1. Триггер   выполняется перед удалением записи из таблицы поставщиков s.  Триггер проверяет наличие  в таблице поставок spj  записей, относящихся к удаляемому поставщику, и, если такие записи есть, удаляет их.

-- Создание триггерной функции
CREATE FUNCTION trigger_s_before_del () RETURNS trigger AS '
BEGIN
if (select count(*) from spj a where trim(a.ns)=trim(OLD.ns))>0
then delete from spj where trim(spj.ns)=trim(OLD.ns);
end if;
return OLD;
END;
' LANGUAGE  plpgsql;


-- Создание триггера
CREATE TRIGGER tr_s_del_befor
BEFORE DELETE ON s FOR EACH ROW
EXECUTE PROCEDURE trigger_s_before_del();


12. В чем разница между WHERE и HAVING?
Предложение HAVING имеет общую форму HAVING условие
Здесь условие задаётся так же, как и для предложения WHERE.
HAVING исключает из результата строки групп, не удовлетворяющих условию. HAVING отличается от WHERE:
WHERE фильтрует отдельные строки до применения GROUP BY, а HAVING фильтрует строки групп,
созданных предложением GROUP BY. Каждый столбец, фигурирующий в условии, должен однозначно ссылаться
на группируемый столбец, за исключением случаев, когда эта ссылка находится внутри агрегатной функции
или негруппируемый столбец функционально зависит от группируемых.

В присутствие HAVING запрос превращается в группируемый, даже если GROUP BY отсутствует.
То же самое происходит, когда запрос содержит агрегатные функции, но не предложение GROUP BY.
Все выбранные строки считаются формирующими одну группу, а в списке SELECT и предложении HAVING
можно обращаться к столбцам таблицы только из агрегатных функций. Такой запрос будет выдавать
единственную строку, если результат условия HAVING — true, и ноль строк в противном случае.

13. Что такое подзапрос (sub-query)?
Подзапрос — это запрос внутри другого запроса, в котором определен запрос для извлечения данных
или информации из базы данных. В подзапросе внешний запрос называется основным запросом,
тогда как внутренний запрос называется подзапросом. Подзапросы всегда выполняются первыми,
а результат подзапроса передается в основной запрос. Он может быть вложен в SELECT, UPDATE
или любой другой запрос. Подзапрос также может использовать любые операторы сравнения,
такие как >, < или =.

Существует два типа подзапросов, а именно: коррелированные и некоррелированные.
Коррелированный подзапрос: это запрос, который выбирает данные из таблицы со ссылкой на
внешний запрос. Он не считается независимым запросом, поскольку ссылается на другую таблицу или
столбец в таблице.
Некоррелированный подзапрос: этот запрос является независимым запросом, в котором выходные данные
подзапроса подставляются в основной запрос.

14. Что такое union?
Все запросы выполняются независимо друг от друга, а уже вывод их - объединяется.
Когда два ( или более ) запроса подвергаются объединению, их столбцы вывода должны быть
совместимы для объединения. Это означает, что каждый запрос должен указывать одинаковое число
столбцов и в том же порядке что и первый, второй, третий, и так далее, и каждый должен иметь тип,
совместимый с каждым.

15. Что такое group by
GROUP BY собирает в одну строку все выбранные строки, выдающие одинаковые значения для выражений
группировки. В качестве выражения внутри элемента_группирования может выступать имя входного
столбца, либо имя или порядковый номер выходного столбца (из списка элементов SELECT), либо
произвольное значение, вычисляемое по значениям входных столбцов. В случае неоднозначности имя в
GROUP BY будет восприниматься как имя входного, а не выходного столбца.

17. Что такое хранимые процедуры?

18. Что такое view(Представление)?
ПРЕДСТАВЛЕНИЕ (VIEW) - ОБЪЕКТ ДАННЫХ КОТОРЫЙ не содержит никаких данных его владельца.
Это - тип таблицы, чье содержание выбирается из других таблиц с помощью выполнения запроса.
Поскольку значения в этих таблицах меняются, то автоматически, их значения могут быть показаны представлением.
Типы таблиц, с которыми мы обычно имеем дело - базовые таблицами. Это - таблицы, которые содержат данные.
Однако имеется другой вид таблиц: - представления. Представления - это таблицы чье содержание выбирается или получается из других таблиц.
Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных.
Представление - это фактически запрос, который выполняется всякий раз, когда представление становится темой команды.
Вывод запроса при этом в каждый момент становится содержанием представления.
Есть команда CREATE VIEW. Она состоит из слов CREATE VIEW (СОЗДАТЬ ПРЕДСТАВЛЕНИЕ), имени представления которое нужно создать, слова AS (КАК), и далее запроса, как в следующем примере:

       CREATE VIEW Londonstaff
          AS SELECT *
          FROM Salespeople
          WHERE city = 'London';
Теперь Вы имеете представление, называемое Londonstaff. Вы можете использовать это представление точно так же как и любую другую таблицу.
Она может быть запрошена, модифицирована, вставлена в, удалена из, и соединена с, другими таблицами и представлениями.
Представления значительно расширяют управление вашими данными. Это - превосходный способ дать публичный доступ к некоторой, но не всей информации в таблице.
Представление может теперь изменяться командами модификации DML, но модификация не будет воздействовать на само представление.
Команды будут на самом деле перенаправлены к базовой таблице.


19. Опишите процесс создания запроса через JDBC.
1. dependency
2. driver
3. import
4. connection ( (url + port + DB), user, passwowrd)
5. preparestatement
6. execute

20. Для чего используется конструкция try-with-resources.