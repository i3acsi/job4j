1. Создал пакет seaBattle.
2. В пакете создал 4 пустых интерфейса: IGame, IPlayGround, IWarship, IPlayer (пока не ясно - что они будут делать, но очевидно, что нужен класс, отвечающий за функционал игрового поля,
	класс, отвечающий за функционал игрока, класс для кораблей, и класс для проведения самой игры. Сами классы пока не зоздаю - создаю голые интерфейсы, которые буду наполять методами,
	(а точнее - описаниями методов))
3. Создал класс PlayGroundTest. - класс, описывающий игровую площадку будет основой, поэтому для начала попробую описать его
4. Создал тест whenCallMethodShowThanPlayGroundDisplayedInConsole - проверка отображения пустого ирового поля в консоли (одна из очевидных и простых операций - отображение поля)
5. В интерфейсе IPlayGround определил метод show
5. Создал тест whenPutAShipOnThePlayGroundAndCallMethodShowThanItDisplayedThere():
	в интерфейсе IPlayGround создал метод boolean place(SimpleWarship ship) (пусть пока будет возвращать boolean результат, потом возможно поменяю это.
	игровое поле будет состоять из ячеек - экземпляров класса SimpleCell - создадим его)
6. Опишем SimpleCell пока так - как я его вижу. Интовые поля X Y - для координат, интовое поле state(хотя можно было использовать например byte) - будет кодировать состояние ячейки.
Сделаю в нем статический метод конвертации корординат пользовательского вида в координаты формата XY (для этого создам и проинициализирую статическое поле с картой соответствия
букв в коодинатах - цифрам)
Переопределю toString() для того, чтобы ячейка отображалась в консоли по разному - в зависимости от состояния state.

Ах да мы же пишем по  TDD  -  вернемся к тестам

7. Создам тесты для SimpleCell: проверка отображения пустой ячейки. проверка оторажения ячейки в разных состояниях. проверка исключения при непавильной инициализии состояния ячейки.
	проверка метода, конвертирующего координаты, переданные пользователем в координаты формата X Y
8. Возвращаюсь к тесту whenPutAShipOnThePlayGroundAndCallMethodShowThanItDisplayedThere(): нужно продумать - как буду инициализировать корабль.
	В классе Warship создаю конструктор, принимающий строку - координаты носа и кормы корабля, разделенные тирэ "-".
	Соответственно нужно создать приватные методы, которые берут эту строку, и отдают массив ячеек Cell, выбрасывая исключения, если во входных данных содержатся ошибки.
9. Создаю тесты и методы для инициализации кораблей.
10. В интерфейсе IPlayGround создал метод void place(List<SimpleWarship> ships), который будет использовать метод boolean place(SimpleWarship ship)
11. В PlayGroundTest создал тесты инициализации одного корабля и списка кораблей (тесты с правильными данными и ошибочными данными
	- т.е. тест того, что нельзя расположить корабли рядом или как-то пересечь их друг с другом)
12. Хорошо. Допустим корабли расположили. Далее необходимо иметь возможность стрелять по полю и попадать в корабли. Делаем тест:
	whenShotAndMissThenGetFalse. Предположим, что результат действия метода в виде true/false нас устроит.
	В IPlayGround создаю метод boolean shoot(String coordinate).
	Делаю тест, проверяющий, что в результате промаха возвращается false, отображение игровоо поля меняется (отображается промах)
	Делаю тест, проверяющий, что в результате попадания возвращается true, отображение ячейки меняется (отображается попадание)
	Делаю тест, проверяющий, что в результате уничтожения корабля, отображение ячеек меняется.
	Делаю тест, проверяющий, что в результате уничтожения всех кораблей, игровое поле возвращает информацию об этом.
	Вроде бы для игрового поля методов достаточно.
13. Разработаю класс, представляющего игрока. У меня уже определен интерфейс IPlayer.
	1. Игрок может расставлять корабли (перед началом игры)
	2. Может стрелять(во время игры)
	3. и то и то может делать человек или компьютер.
14. Разберусь сначала  с последним пунктом. 

//todo13. В интерфейсе IGame создаю метод
	int singleGameStart(IPlayGround playGround, IPlayer player1, IPlayer player2);
	он возвращает целое число для идентификации победителя,
	он принимает экземпляр класса, реализующего интерфейс IPlayGround являющегося ировой площадкой