1. Что такое SOLID?
Это аббривеатура, где каждая буква обозначает отдельный принцип проектирования приложений (т.е некоторые правила разработки
как отдельных классов, так и их совокупности). Эти принципы позволяют сделать код более читаемым, масштабируемым, такой код
проще поддерживать и тестировать. Подходы, которые выработаны программистами с большим опытом

2. Для чего используются JavaDoc?
- это стандарт для документирования классов Java. (Может генерировать документацию в HTML формате)
Комментарии документации применяют для:
	документирования классов,
	интерфейсов,
	полей (переменных),
	конструкторов,
	методов,
	пакетов.
	
3. Как писать JavaDoc?
/**
 * Перед описываемым классом, методом и т.д.
 * Общее описание
 * @author, @since, @version
 * @param - входящие параметры метода
 * @return - что возвращает
 */

Для документирования переменной можно использовать следующие дескрипторы: @see, @serial, @serialField, {@value}, @deprecated.
Для классов и интерфейсов можно использовать дескрипторы: @see, @author, @deprecated, @param, @version.
Методы можно документировать с помощью дескрипторов: @see, @return, @param, @deprecated, @throws, @serialData, {@inheritDoc}, @ехсерtion.
Дескрипторы {@link}, {@docRoot}, {@code}, {@literal}, @since, {@linkplain} могут применяться где угодно.

4. Что такое Java code convention?
Java code conventions - это соглашение принятое компанией Sun Microsystems для поддержания чистоты и единообразия исходного кода.
Программы гораздо проще поддерживать, когда все файлы имеют согласованный стиль.

5. Расскажите про принципы составления Java класса.
Каждый java - файл имеет описывает один публичный класс (интерфейс, абстрактный класс)
Сначала - Начальный комментарий (перечисленны авторы программы, дата, сведения об авторских правах, а так же кратко описание того,
что делает программа.), затем - Операторы package и import, затем - обьявления классов и интефейсов

6. Что такое SRP?
Принцип персональной ответственности (SRP Single Responsibility Principle) - “Существует лишь одна причина, приводящая к изменению класса”
 Чем больше обязанностей у класса, тем больше запросов на изменение он получит, и тем сложнее будет реализовать эти изменения.
 Цель принципа SRP – бороться со сложностью, которая возникает в процессе разработки логики приложения.
 По-сути это декомпозиция класса на классы с узким назначением
Когда пишем Javadoc - мы, например, описывем что делает метод,
и если мы через запятую начинаем перечислять то, что делает метод, то мы, скорее всего, нарушили SRP.
С другой стороны - если сильно увлечься с разбиением, то такой код тоже будет сложно поддерживать

7. Расскажите о нарушениях принципе SRP?
Декомпозиция кода уменьшает его сложность.
Unit-тестирование декомпозированого кода упрощается и становится более эффективным.
Декомпозированый код проще изменять. При внесении изменений меньше вероятность внести ошибку.
Код становится лучше структурирован. Искать что-то в коде разложеном по файлам и папкам намного легче чем в одной большой портянке.

Признаки нарушения: Большие(длинные) методы, много импортов, Если на основное назначение функции нужно написать два десятка тестов,
 не считая пограничных случаев и т.д., значит нужна декомпозиция.

8. Последствия нарушения SRP?
Всегда нужно сохранять баланс между количеством классов и их необходимостью.

9. Что такое OCP?
Значит чтобы было легко изменять поведение модуля без изменения его исходного кода.
Модуль называют открытым, если он еще доступен для расширения. Например, имеется возможность расширить множество операций в нем или добавить поля к его структурам данных.
Модуль называют закрытым, если он доступен для использования другими модулями. Это означает, что модуль
(его интерфейс – с точки зрения скрытия информации) уже имеет строго определенное окончательное описание.
 На уровне реализации закрытое состояние модуля означает, что модуль можно компилировать, сохранять в библиотеке
 и делать его доступным для использования другими модулями (его клиентами).

дизайн системы должен быть простым и устойчивым к изменениям.

Это фиксация интерфейса класса/модуля, и возможность изменения или подмены реализации/поведения.

Цели OCP: борьба со сложностью и ограничение изменений минимальным числом модулей.

Как мы реализуем OCP? С помощью инкапсуляции, которая позволяет изменять реализацию без изменения интерфейса
 и с помощью наследования, что позволяет заменить реализацию, которая не затронет существующих клиентов базового класса.
10. Расскажите о нарушениях принципе OCP?
Любое рабочее приложение обходимо ингода менять, добавлять новый функционал. Это ведет к изменению тэстов, т.о. количество работы будет расти как ежный ком.
Когда мы пытаемя расширить продукт методом его изменнений - продукт начинает расти, методы начинают растии
изменение кода в одном месте отразится на его использовании в других местах 
Соответственно КОД СТАНОВИТСЯ сложнее поддреживать
Способов сделать расширение много - 

11. Последствия нарушения OCP?

12. Что такое LSP?
Должна быть возможность вместо базового типа подставить любой его подтип.
Должна существовать возможность использовать объекты производного класса вместо объектов базового класса.
Это значит, что объекты производного класса должны вести себя согласованно, согласно контракту базового класса.
Принцип подстановки Лисков призван помочь в корректной реализации наследования, что также должно помочь отказаться от наследования, если его корректная реализация невозможна.

Наследование обычно моделирует отношение "ЯВЛЯЕТСЯ" (IS-A Relationship) между классами. Говорят, что экземпляр наследника также ЯВЛЯЕТСЯ экземпляром базового класса,
что выражается в возможности использования экземпляров наследника везде, где ожидается использование базового класса.

Контракт абстракции(не важно, формальный или нет) описывает ожидаемое видимое поведение абстракции, оставляя реализации решать, каким образом это поведение будет реализовано.

Если же реализация (т.е. наследники) не будет знать о протоколе «абстракции» или не будет ему следовать, то в приложении мы будем вынуждены обрабатывать
конкретную реализацию специальным образом, что сводит на нет идею использования «абстракции» и наследования.


13. Расскажите о нарушениях принципе LSP?

14. Последствия нарушения LSP?
передача в метод экземпляра класса-наследника приведет к странному поведению существующего кода.
Поскольку в противном случае юнит-тесты базового класса никогда не будут проходить для наследников.»

15. Что такое ISP?
Принцип разделения интерфейса (ISP, Interface Segregation Principle)


16. Расскажите о нарушениях принципе ISP?
Если мы создаем большой интерфейс, то нам необходимо поддерживать его реализацию для всех классов, реализующих данный интерфейс.

17. Последствия нарушения ISP?

18. Что такое DIP?
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Мы должны разбивать нашу программу на модули, а эти модули должны быть связаны между собой абстракцией. А абстракция не болжнабыть связана с деталями.


19. Расскажите о нарушениях принципе DIP?

20. Последствия нарушения DIP?

21. Расскажите что такое автоматическое тестирование?
Мы проверяем классы и (главным образом) публичные методы класса. Для этого пишутся программы-тесты. Например фукция квадратного корня
принимает в себя число, и аозвращает его квадратный корень. Мы создаем класс, содержащий публичные методы, которые тем или иным
способом проверяют тестируемые методы. С помощью функции assertthat мы можем сравнить полученныые результаты и ожидаемые
для разных вариантов входных параметров. Если проверка не пройдена - программа нам об этом сообщит, так же она сообщит - в каком месте произошла ошибка.

Обычно используют два вида автоматических тестов:
Модульное тестирование (тестирование отдельных частей продукта, обычно отдельных функций/методов)
Функциональное тестирование — тестирование некого функционала продукта, при этом продукт воспринимается как единый «чёрный ящик».

существует огромное число функций, проверить которые модульным тестированием невозможно, либо очень сложно
(это функции, поведение которых зависит от состояния системы в целом).

правильная работа всех модулей системы, отнюдь не гарантирует их правильное взаимодействие.

Успешное прохождение всех юнит-тестов не гарантирует правильной работы продукта: ведь одна и та же функция может быть
использована в различных частях системы, в то время как юнит-тест писался для неё с оглядкой лишь на один вариант использования.

модульное тестирование великолепный инструмент, если вы пишите некую библиотеку, предназначенную для использования многими разработчиками
— в этом случае модульные тесты будут выполнять и роль документации к функциям
(ведь не секрет, что мы часто пропускаем описание функции и сразу смотрим примеры использования).

22. Как в Java осуществляется автоматическое тестирование?
JUnit - популярный фреймворк для тестирования

23. Что такое JUnit? Как использовать для тестирования?

24. Что такое функциональное тестирование чем отличается от модульного?
 Как правило, они пишутся тестерами. У которых стоит задача найти ошибку (по крайней мере своим тестерам мы всегда ставим такую задачу).
 А значит будет больше проверок на нестандартные данные

функциональными тестами гораздо проще покрывать готовый продукт, чем модульными
— т. к. гораздо проще понять что конкретно должна и не должна делать определённая
часть пользовательского интерфейса, чем определить что ДОЛЖНА делать данная функция.
И самая большая прелесть — вы можете начать покрывать функциональными тестами только
самые важные части продукта — и они будут исправно гарантировать их работоспособность.

Функциональные тесты полностью определяют (по крайней мере должны) работоспособность продукта. И прежде всего нужны заказчику/руководителю разработки.
Юнит тестирование прежде всего нужно самим разработчикам, для быстрого нахождения ошибок или проверки последствий рефакторинга.

25. Расскажите про принцип TDD?
first test than codding 
Ключевое слово Driven в TDD означает, что сначала пишется тест (который задает, что должно быть и как должна работать система),
а потом уже пишется код. Т.е. TDD — это не набор определенных тестов, это — методология (стиль) процесса разработки.
Точно так же BDD — это не набор определенных тестов, это идея процесса разработки, часть которого — написание тестов.

26. Расскажите про принцип BDD?
Behavior-driven development, дословно «разработка через поведение»)
— это методология разработки программного обеспечения, являющаяся ответвлением от методологии TDD
BDD методология является расширением TDD в том смысле,
что перед тем как написать какой-либо тест необходимо сначала описать желаемый результат от
добавляемой функциональности на предметно-ориентированном языке. После того как это будет проделано,
конструкции этого языка переводятся специалистами или специальным программным обеспечением в описание теста.
BDD asks questions about behavior of app before and during development to reduce miscommunication.
BDD concentrates on behavior of app vs. implementation of app.
Idea (BDD): user story can be formulated as acceptance test before code is written.
Test Driven Design or TDD tests implementation.

BDD фокусируется на следующих вопросах:

С чего начинается процесс.
Что нужно тестировать, а что нет.
Сколько проверок должно быть совершено за один раз.
Что можно назвать проверкой.
Как понять, почему тест не прошёл.
Исходя из этих вопросов, BDD требует, чтобы имена тестов были целыми предложениями, которые начинаются с глагола
в сослагательном наклонении и следовали бизнес целям. Описание приемочных тестов должно вестись на гибком
языке пользовательской истории, например,



27. Что такое тестирование черным ящиком
Под «чёрным ящиком» понимается объект исследования, внутреннее устройство которого неизвестно.
Мы рассматриваем весь наш код как ЧЯ(нас не интересуеют конкретные реализации)
Мы знаем по документацци как приложение должно работать. Т.е. мы имеем входящие параметры, и результат (который можно сравнить с ожидаемым)
Так называемое «black-box тестирование» является методом тестирования программного обеспечения, внутренняя структура, дизайн и
реализация которого неизвестна тестировщику (при подготовке тест-кейсов он опирается на требования и спецификацию).
Хочу обратить внимание на то, что требования и спецификация не всегда существуют в письменном виде; тем не менее,
при тестировании методом черного ящика мы можем опираться на устно описанные требования.


TDD тесты морской бой