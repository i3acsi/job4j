1. Расскажите общее идею что такое поток ввода-вывода?
Идея в том что помимо тех объектов которые мы создаем в процессе написания программы
можно вводить какие-то данные в процессе ее работы. Это могут быть любые объекты которые потдерживает
java. Можно организовать как ввод строки так и принять объект какого-то класса в том числе и 
созданного самостоятельно.
====================
2. Что такое Java IO?
IO это пакет который обеспечивает процесс обмена данными с внешней средой выходящей за рамки программы.
Представляет из себя две группы интерфейсов ввода-вывода: символьный и байтовый. Является блокирующем,
тоесть когда поток(stream) ждет данных поток (thred) только этим и занят(заблокирован).

2.1 Символьный представлен двумя интерфейсами Reader и Writer
2.1.1 Reader это интерфейс который реализуют следующие классы: BufferedReader, FilterReader, PipedReader и 
InputStreamReader который имеет наследника FileReader для чтения текста из файла.

2.1.2 Writer это интерфейс реализуемый классами: BufferedWriter, FilterWriter, PipedWriter, PrintWriter и
OutputStreamWriter который имеет наследника FileWriter для записи текста в файл.


2.2 Байтовый представлен двуми интерфейсами InputStream и OutputStream.
2.2.1 InputStream реализуется классами: ObjectInputStream, FileInputStream, PipedInputStream, и 
FilterInputStream который имеет наследников: DataInputStream, BufferedInputStream, PushBackInputStream.

2.2.2 OutputStream реализован через ObjectOutputStream, FileOutputStream, PipedOutputStream и 
FilterOutputStream имеющий наследников: DataOutputStream, BufferedOutputStream.
====================
3. Что такое Java NIO?
NIO это дополнение к IO но он:
1. Буферо-ориентированный в отличие от IO который потоко-ориентированый.
2. Имеет не блокирующий асинхронный ввод-вывод, в отличие от IO. Тоесть stream данных пока нет то thred
можед заняться чем-то еще пока данные для stream не появятся.
3. Имеет селекторы которые позволяют мониторить сразу несколько потоков ввода одним принимаемым потоком.

====================
4. Что такое Scanner? 
5. Как работает Scanner внутри?
Scanner, позволяет выделять примитивы и строки из входного потока. Он разбивает входной поток на токены (используя
регулярные выражения, а в качестве разделителя токенов поумолчанию – пробел и переход на новую строку), которые затем,
с помощью предопределенных методов, преобразуются в различные типы. java.util.Scanner позволяет считывать данные с различных потоков. 
У сканнера усть множество разных конструкторов, которые отличаются источником, а так же можно передать Charset (кодировку).
Так же стоит отметить, что сканнер реализует интерфейс iterator (т.о. содержит методы next и hasNext)
Источниками могут быть: Readable(является источником символов), есть метод read (Пытается прочитать символы в указанном буфере символов)
			InputStream (который передается в конструктор InputStreamReader)
			File. файл передается в FileInputSream и методом getChanel получаем FileChannel, котрый преобразум в ReadableByteChannel
			ReadableByteChannel (+ charset) передается в метод makeReadable, котрый возвращает Reader.
по умолчанию разделитель - пробел, разделитель можно специфицировать.
есть методы hasNext(?) - Boolean, Byte, Short, Long, Int, Float, Double (Возвращает true, если токен из входного потока можно интерпретировать
как ?), Line - true, если во входном потоке найден символ конца строки
и симметричные методы next. Методы могут блокироваться в ожидании входных данных. Если введенные пользователем данные не могут быть интерпретированы
в соответствии с вызываемым методом сканера, то возникнет ошибка времени выполнения программы.
Так же, можно специфицировать используемую локаль - useLocale, систему счисления - useRadix
есть метод close, котрый пытается вызвать метод close у источника

6. Какие базовые методы существуют в Scanner?

7. Что такое байтовый поток? Как он реализован внутри?
Определены двумя абстрактными классами - InputStream OutputStream. is - основные методы - int available()- количество байт вводимых данных, доступных в данный момент для чтения
								close, void mark (устанавливает метку на текущей позиции в потоке), boolean markSupotred
								int read() читает следующий байт, доступный в потоке ввода, если данные кончились - то -1
								int read(Byte buf[])Пытается прочитать в передаваемый буфер, возвращает количество успешно прочитанных байт или -1
								int read(Byte buf[], int смещение, int кол-во байт) -//- кол-во байт, начиная с позиции
								long skip(long кол-во байт)
				FileInputStream - создается объект типа InputStream, который можно использовать для чтения байов из файла
				ByteArrayInputStream - реализует поток ввода, использующий ассив байт в качестве источника.
				Консьркутор: byte[] array; byte[] array, int begin, int byte_count
				
				- os- основные методы close - закрывает поток вывода
						-flush()- финализирует выходное состояние так, что все буферы очищаются
						- write(int b) - записывает единственный байт в поток вывода
						- write(byte buf[]) - записывает массив байт в поток вывода
						- write(byte buf[], int смещение, int колво байт) - записывает часть заданного колва байт из массива, начиная с позиции
				FileOutputStream - создается объект типа OutputStream, который можно использовать для записи байтов в файл.
				В конструктор принимает String - полный путь к файлу или File, а так же опционально - boolean параметр "добавить" - открывает файл для добавления данных
				ByteArrayOutputStream, - c конструктором по умолчанию - создается буфер размером 32 байта, или коструктро int - количество байт

8. Что такое символьный поток? Как он реализован внутри?
Определены двумя абстрактными классами - Reader и Writer. Reader - AutoCloseable, Closeable, Readable. Симметричен  is 
						- int read() -целочисленное представление следующего символа
						- int read(char buf[]) пытается прочитать в буфер количество символов = длинне буфера
						- int read(CharBuffer buf)
						- abs int read(char buf[], int смещение, int колво символов)
						- boolen ready - true, усли следующий запрос на ввод не будет ждать
						- reset, skip
	FileReader - лдя чтения содержимого файла. В конструктор принимает String путь; File file
	CharArrayReader - реализует поток вывода, использующий массив в качестве источника данных. Есть 2 конструктора, каждый из которых принимает char[] в качестве источника данных
char[] array; char[] array, int begin, int symbol_count
	BufferedReader - увеличивает производительность благодаря буферизации ввода. Есть 2 конструктора: Reader stream; Reader stream, int buffer



				Writer - AutoCloseable, Closeable, Flushable, Appendable
						-append(char c) Присединяет указанный символ в конце вызывающего потока вывода. Возвращает ссылку на вызывающий поток вывода
						-append(CharSequence chars)
						-append(CharSequence chars, int begin, int end)
						-close
						-flush - делает конечным состояние вывода, очищая все буфера
						-write(int char)
						-write(char buf[])
						-write(char buf[], int смещение, int колво символов)
						-write(String str)
						-write(String str, int смещение, int колво символов)
	FileWriter - для записи данных в файл. В конструктор принимает String путь + опц.(boolen add); File file + опц.(boolean add). Если файл не существует - то он создается
если существует, но с атрибутом readOnly - IOException.
	CharArrayWriter - char[] в качестве адресата выводимых данных. Есть 2 Конструктора: по умолчанию; int symbol_count. - Создается буфер с заданным размером.
При этом размер буфера растет по мере надобности 
 

9. Что такое буферизированный поток?
	Фильтруемые потоки - оболочки, в которые заключаются базовые потоки для расширения их функциональных возможностей. Такие потоки обычно доступны методам,
которые ожидают обобщенный поток, служащий суперклассом для фильтруемого потока. Типичными расширениями функций этих потоков являются преобразование исходных данных и
буферизация. Буферизированные потоки расширяют класс фильтруемого потока, присоединяя к нему буфер. Буфер позволяет выполнять операции ввода-вывода не одного байта,
а нескольких байт за одну опреацию - повышая производительность. Реализуются классами BufferedIS BufferedOS PushbackIS
	BufferedIS - позволяет обернуть любой поток ввода типа IS. Имеется 2 котструктора: IS stream; IS stream, int размер буфера. Поддерживает методы mark и reset
	BufferedOS - предназначен для повышения производительности за счет сокращения количества операций записи. метод flush - инициализирует немедленнную запись всех данных из буфера
	PushbackIS - позволяет просмотреть поток ввода, не извлекая данные. Констркутор: IS stream; IS stream, int количество байт
для первого конструктора- можно вернуть 1 байт в указанный поток ввода. 2й конструктор - создается поток ввода с буферомвозврата указанной длинны - можно вернуть заданное количество байт
добавляется метод unread(int b) (byte[] buf) (byte[] buf, int смещение, int количество байт)
10. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вызов?
//todo
(Класс PrintStream предоставляет все возможности для вывода данных по дескриптору файла System.out типа System) узнать подробней
//todo
Класс printStream реализует интерфейсы Appendable, AutoCloseable, Closeable, Flushable. конструктор: OS stream; OS stream, boolean автоочистка; OS stream, bool ac, String str
Параметр автоочистка - определяет - будет ли буфер вывода автоматически очищаться при каждой записи последовательности символов для новой строки (\n), записи byte[], или при вызове метода println
Первый конструктор не предполагает автточистку. Можно задать кодировку передав ее в качестве набора символов. Т.о. в конструктор можно передать File file.
Поддерживаются методы print и println - для вывода всех тиипов, включая Object (если аргумент - не примитив, то сначала вызывается метод toString())
для форматированного вывода есть метод printf(). Для форматирования используются методы класса Formatter. в конструктор можно передать
String форматирующая строка, Object аргументы; Locale рег. настройки, String форматирующая строка, Object аргументы
В результате возвращается вызывающий поток вывода в виде объекта PrintStream. Стандартный поток вывода относится к PrintSream.
  
11. Как осуществлятся ввод и вывод из командной строки?
В классе System определены static переменные out и in. out - объект типа PrintStream, in - InputStream
есть методы setIn, setOut
Стандартный поток вывода System.out, ввода - System.in; System.in можно обернуть в сканнер или так
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

12. Что такое класс Console? Расскажите его АПИ.


13. Что такое поток данных? Data stream.
Классы DataOS (IS) позволяют выводить примитивные данные в поток или выводить из потока. Такие потоки упрощают сохранение в файле данных, представленных в двоичной форме.
DataOS расширяет класс FilterOS(кототрый в свою очередь расширяет OS), реализует интерфейсы AutoClseable, Closeable, Flushable, (DataOutput)
В конструктор принимает OS stream
В интерфейсе DataOutput определны методы, сначала преобразющие значения примитивных типов в последовательности байт, а затем выводящие их в базовый поток:
writeDouble, writeBoolean, writeInt
DataIS является дополнением класса DataOS для ввода примитивных данных в двоичной форме. Он расширяет класс FilterIS(кототрый в свою очередь расширяет IS)
реализует интрефейсы AutoCloseable, Closeable; в конструктор принимает IS stream. Есть методы, определенные в DataInput:
double readDouble, boolean readBoolean, int readInt
//
RandomAccessFile так же реализует интерфейсы DataInput, DataOutput (+ AutoCloseable, Closeable) инкапсулирует файл произвольного доступа.
В конструктор принимает File file, String access; String file, String access. r- только чтение, rw - чтение и запись, rws - rw + каждое зменение файла приводит к записи на физ. устройство.
метод seek(long new_possition) - для установки указателя файла на текущей позиции в этом файле. long new_pos - новая позиция указателя файла, отсчитываемя в байтах от начала файла.
после вызова метода seek, следующая операция чтения/записи будет выполняться с новой позиции.
RAF реализут стандартные методы ввода/вывода, которые можно использовать для чтения/ записи файлов с произвольным доступом. 
readUTF, readLine, setLength(устанавливает заданную длинну вызывающего файла)


14. Что такое поток объектов, Object stream.
15. Что такое Path? Как он реализуется на разных ОС?

16. Как получить список файлов?
класс File:
	1. Создание объекта класса File:
		File(String путь)
		File(String путь, String name)
		File(File объет_каталога, String name)
		File(URI объект_URI)
	2. Если созданный объект - существует и он - дирректория, то у него можно вызвать метод list(куда можно передать FileNameFilter) 
											и listFiles(куда можно передать FileNameFilter или FileFilter)
	в первом случае получим массив строк, зодержащих полный путь к файлам
	во втором - массив объектов File

	в интрефейсе FilenameFilter определен единственный метод accept(File dir, String file_name), который вызывается каждым файлом из списка.
	в интрефейсе FileFilter  определен единственный метод accept(File path), который вызывается каждым файлом из списка.

17. Как проверить что файловая сущность является файлом или папкой?
класс File:

18. Как удалить файл?
класс File:
	1. Создать объект класса File
	2. boolean delete. (можно так же удалить каталог, если он пуст) 

19. Как переместить файл?
класс File:

20. Как управлять аттрибьтами файла?
класс File:
	.setExecutable()
	.setLastModified()
	setReadable()
	.setReadOnly()
	.setWritable()
	
									

21. Как создать файл? 
класс File:

22. Как создать директорию?
класс File:
mkdir() mkdirs()

23. Как записать в файл?
класс File:

24. Как прочитать данные из файла?
класс File: