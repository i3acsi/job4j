1. Расскажите общее идею что такое поток ввода-вывода?
Идея в том что помимо тех объектов которые мы создаем в процессе написания программы
можно вводить какие-то данные в процессе ее работы. Это могут быть любые объекты которые потдерживает
java. Можно организовать как ввод строки так и принять объект какого-то класса в том числе и 
созданного самостоятельно.
====================
2. Что такое Java IO?
IO это пакет который обеспечивает процесс обмена данными с внешней средой выходящей за рамки программы.
Представляет из себя две группы интерфейсов ввода-вывода: символьный и байтовый. Является блокирующем,
тоесть когда поток(stream) ждет данных поток (thred) только этим и занят(заблокирован).

2.1 Символьный представлен двумя интерфейсами Reader и Writer
2.1.1 Reader это интерфейс который реализуют следующие классы: BufferedReader, FilterReader, PipedReader и 
InputStreamReader который имеет наследника FileReader для чтения текста из файла.

2.1.2 Writer это интерфейс реализуемый классами: BufferedWriter, FilterWriter, PipedWriter, PrintWriter и
OutputStreamWriter который имеет наследника FileWriter для записи текста в файл.


2.2 Байтовый представлен двуми интерфейсами InputStream и OutputStream.
2.2.1 InputStream реализуется классами: ObjectInputStream, FileInputStream, PipedInputStream, и 
FilterInputStream который имеет наследников: DataInputStream, BufferedInputStream, PushBackInputStream.

2.2.2 OutputStream реализован через ObjectOutputStream, FileOutputStream, PipedOutputStream и 
FilterOutputStream имеющий наследников: DataOutputStream, BufferedOutputStream.
====================
3. Что такое Java NIO?
NIO это дополнение к IO но он:
1. Буферо-ориентированный в отличие от IO который потоко-ориентированый.
2. Имеет не блокирующий асинхронный ввод-вывод, в отличие от IO. Тоесть stream данных пока нет то thred
можед заняться чем-то еще пока данные для stream не появятся.
3. Имеет селекторы которые позволяют мониторить сразу несколько потоков ввода одним принимаемым потоком.

====================
4. Что такое Scanner? 
5. Как работает Scanner внутри?
Scanner, позволяет выделять примитивы и строки из входного потока. Он разбивает входной поток на токены (используя
регулярные выражения, а в качестве разделителя токенов поумолчанию – пробел и переход на новую строку), которые затем,
с помощью предопределенных методов, преобразуются в различные типы. java.util.Scanner позволяет считывать данные с различных потоков. 
У сканнера усть множество разных конструкторов, которые отличаются источником, а так же можно передать Charset (кодировку).
Так же стоит отметить, что сканнер реализует интерфейс iterator (т.о. содержит методы next и hasNext)
Источниками могут быть: Readable(является источником символов), есть метод read (Пытается прочитать символы в указанном буфере символов)
			InputStream (который передается в конструктор InputStreamReader)
			File. файл передается в FileInputSream и методом getChanel получаем FileChannel, котрый преобразум в ReadableByteChannel
			ReadableByteChannel (+ charset) передается в метод makeReadable, котрый возвращает Reader.
по умолчанию разделитель - пробел, разделитель можно специфицировать.
есть методы hasNext(?) - Boolean, Byte, Short, Long, Int, Float, Double (Возвращает true, если токен из входного потока можно интерпретировать
как ?), Line - true, если во входном потоке найден символ конца строки
и симметричные методы next. Методы могут блокироваться в ожидании входных данных. Если введенные пользователем данные не могут быть интерпретированы
в соответствии с вызываемым методом сканера, то возникнет ошибка времени выполнения программы.
Так же, можно специфицировать используемую локаль - useLocale, систему счисления - useRadix
есть метод close, котрый пытается вызвать метод close у источника

6. Какие базовые методы существуют в Scanner?

7. Что такое байтовый поток? Как он реализован внутри?
Определены двумя абстрактными классами - InputStream OutputStream. is - основные методы - int available()- количество байт вводимых данных, доступных в данный момент для чтения
								close, void mark (устанавливает метку на текущей позиции в потоке), boolean markSupotred
								int read() читает следующий байт, доступный в потоке ввода, если данные кончились - то -1
								int read(Byte buf[])Пытается прочитать в передаваемый буфер, возвращает количество успешно прочитанных байт или -1
								int read(Byte buf[], int смещение, int кол-во байт) -//- кол-во байт, начиная с позиции
								long skip(long кол-во байт)
				FileInputStream - создается объект типа InputStream, который можно использовать для чтения байов из файла
				ByteArrayInputStream - реализует поток ввода, использующий ассив байт в качестве источника.
				Консьркутор: byte[] array; byte[] array, int begin, int byte_count
				
				- os- основные методы close - закрывает поток вывода
						-flush()- финализирует выходное состояние так, что все буферы очищаются
						- write(int b) - записывает единственный байт в поток вывода
						- write(byte buf[]) - записывает массив байт в поток вывода
						- write(byte buf[], int смещение, int колво байт) - записывает часть заданного колва байт из массива, начиная с позиции
				FileOutputStream - создается объект типа OutputStream, который можно использовать для записи байтов в файл.
				В конструктор принимает String - полный путь к файлу или File, а так же опционально - boolean параметр "добавить" - открывает файл для добавления данных
				ByteArrayOutputStream, - c конструктором по умолчанию - создается буфер размером 32 байта, или коструктро int - количество байт

8. Что такое символьный поток? Как он реализован внутри?
Определены двумя абстрактными классами - Reader и Writer. Reader - AutoCloseable, Closeable, Readable. Симметричен  is 
						- int read() -целочисленное представление следующего символа
						- int read(char buf[]) пытается прочитать в буфер количество символов = длинне буфера
						- int read(CharBuffer buf)
						- abs int read(char buf[], int смещение, int колво символов)
						- boolen ready - true, усли следующий запрос на ввод не будет ждать
						- reset, skip
	FileReader - лдя чтения содержимого файла. В конструктор принимает String путь; File file (не принимает CharSet,так что лучше создать ISReader)
	CharArrayReader - реализует поток вывода, использующий массив в качестве источника данных. Есть 2 конструктора, каждый из которых принимает char[] в качестве источника данных
char[] array; char[] array, int begin, int symbol_count
	BufferedReader - увеличивает производительность благодаря буферизации ввода. Есть 2 конструктора: Reader stream; Reader stream, int buffer
Аналагично BufferedIS - BR - так же поддерживает перемещение обратно по потоку ввода в пределах доступного буфера (с помощью методов mark , reset)
метод lines - возвращает Stream<String>
	PushbackReader - позволяет возвратить в поток ввода1 и более символов, не выводя из него данные. 2 конструктора:
Reader stream; Reader stream, int buffer. Метод unread - возвращает 1 и более символов в вызывающий поток ввода:
unread(int char); unread(char[] buffer); unread(char[] buffer, int смещение, int количество символов). В первом случае в поток ввода возвращается указанный символ,
это будет символ, который будет получен при следующем вызове метода read. Во втором случае в поток ввода возвращаются символы из буфера. А в 3м - кол-во симвлов из буфера начиная со (смещение)

				Writer - AutoCloseable, Closeable, Flushable, Appendable
						-append(char c) Присединяет указанный символ в конце вызывающего потока вывода. Возвращает ссылку на вызывающий поток вывода
						-append(CharSequence chars)
						-append(CharSequence chars, int begin, int end)
						-close
						-flush - делает конечным состояние вывода, очищая все буфера
						-write(int char)
						-write(char buf[])
						-write(char buf[], int смещение, int колво символов)
						-write(String str)
						-write(String str, int смещение, int колво символов)
	FileWriter - для записи данных в файл. В конструктор принимает String путь + опц.(boolen add); File file + опц.(boolean add). Если файл не существует - то он создается
если существует, но с атрибутом readOnly - IOException.
	CharArrayWriter - char[] в качестве адресата выводимых данных. Есть 2 Конструктора: по умолчанию; int symbol_count. - Создается буфер с заданным размером.
При этом размер буфера растет по мере надобности
	BufferedWriter - производный от Writer, буферизирует выводимые данные.Повышает производительность за счет снижения количества операций записи на физ. устройство. 2 конструктора:
Writer stream; Writer stream, int buffer
	PrintWriter - символьная версия PrintStream. Есть 4 конструктора OS stream; OS stream, boolean autoclean; Writer stream; Writer stream, boolean autoclean
поддерживается метод printf 

9. Что такое буферизированный поток?
	Фильтруемые потоки - оболочки, в которые заключаются базовые потоки для расширения их функциональных возможностей. Такие потоки обычно доступны методам,
которые ожидают обобщенный поток, служащий суперклассом для фильтруемого потока. Типичными расширениями функций этих потоков являются преобразование исходных данных и
буферизация. Буферизированные потоки расширяют класс фильтруемого потока, присоединяя к нему буфер. Буфер позволяет выполнять операции ввода-вывода не одного байта,
а нескольких байт за одну опреацию - повышая производительность. Реализуются классами BufferedIS BufferedOS PushbackIS
	BufferedIS - позволяет обернуть любой поток ввода типа IS. Имеется 2 котструктора: IS stream; IS stream, int размер буфера. Поддерживает методы mark и reset
	BufferedOS - предназначен для повышения производительности за счет сокращения количества операций записи. метод flush - инициализирует немедленнную запись всех данных из буфера
	PushbackIS - позволяет просмотреть поток ввода, не извлекая данные. Констркутор: IS stream; IS stream, int количество байт
для первого конструктора- можно вернуть 1 байт в указанный поток ввода. 2й конструктор - создается поток ввода с буферомвозврата указанной длинны - можно вернуть заданное количество байт
добавляется метод unread(int b) (byte[] buf) (byte[] buf, int смещение, int количество байт)

10. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вызов?
//todo
(Класс PrintStream предоставляет все возможности для вывода данных по дескриптору файла System.out типа System) узнать подробней
//todo
Класс printStream реализует интерфейсы Appendable, AutoCloseable, Closeable, Flushable. конструктор: OS stream; OS stream, boolean автоочистка; OS stream, bool ac, String str
Параметр автоочистка - определяет - будет ли буфер вывода автоматически очищаться при каждой записи последовательности символов для новой строки (\n), записи byte[], или при вызове метода println
Первый конструктор не предполагает автточистку. Можно задать кодировку передав ее в качестве набора символов. Т.о. в конструктор можно передать File file.
Поддерживаются методы print и println - для вывода всех тиипов, включая Object (если аргумент - не примитив, то сначала вызывается метод toString())
для форматированного вывода есть метод printf(). Для форматирования используются методы класса Formatter. в конструктор можно передать
String форматирующая строка, Object аргументы; Locale рег. настройки, String форматирующая строка, Object аргументы
В результате возвращается вызывающий поток вывода в виде объекта PrintStream. Стандартный поток вывода относится к PrintSream.
  
11. Как осуществлятся ввод и вывод из командной строки?
В классе System определены static переменные out и in. out - объект типа PrintStream, in - InputStream
есть методы setIn, setOut
Стандартный поток вывода System.out, ввода - System.in; System.in можно обернуть в сканнер или так
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

12. Что такое класс Console? Расскажите его АПИ.
Служит для ввода-вывода данных на консоль, если она есть. Интерфейс Flushable. Функционирует, главным образом через System.in, System.out.
Его экземпляр получается вызовом метода System.console(); если консоль доступна - возвращается ссылка на нее, иначе - null.
метод flush - вывод буферизированных данных в консоль; printf; Reader reader возвращает ссылку на поток чтения типа Reader, связанный с консолью
readLine, readPassword, Writer writer

13. Что такое поток данных? Data stream.
Классы DataOS (IS) позволяют выводить примитивные данные в поток или выводить из потока. Такие потоки упрощают сохранение в файле данных, представленных в двоичной форме.
DataOS расширяет класс FilterOS(кототрый в свою очередь расширяет OS), реализует интерфейсы AutoClseable, Closeable, Flushable, (DataOutput)
В конструктор принимает OS stream
В интерфейсе DataOutput определны методы, сначала преобразющие значения примитивных типов в последовательности байт, а затем выводящие их в базовый поток:
writeDouble, writeBoolean, writeInt
DataIS является дополнением класса DataOS для ввода примитивных данных в двоичной форме. Он расширяет класс FilterIS(кототрый в свою очередь расширяет IS)
реализует интрефейсы AutoCloseable, Closeable; в конструктор принимает IS stream. Есть методы, определенные в DataInput:
double readDouble, boolean readBoolean, int readInt
//
RandomAccessFile так же реализует интерфейсы DataInput, DataOutput (+ AutoCloseable, Closeable) инкапсулирует файл произвольного доступа.
В конструктор принимает File file, String access; String file, String access. r- только чтение, rw - чтение и запись, rws - rw + каждое зменение файла приводит к записи на физ. устройство.
метод seek(long new_possition) - для установки указателя файла на текущей позиции в этом файле. long new_pos - новая позиция указателя файла, отсчитываемя в байтах от начала файла.
после вызова метода seek, следующая операция чтения/записи будет выполняться с новой позиции.
RAF реализут стандартные методы ввода/вывода, которые можно использовать для чтения/ записи файлов с произвольным доступом. 
readUTF, readLine, setLength(устанавливает заданную длинну вызывающего файла)

14. Что такое поток объектов, Object stream.
Сериализация - процесс записи состояния объектров в поток вывода байт. Используется для записи состоянияпрограммы в файле.
Средствами сериализации может быть сохранен и восстановлен только объект класса, реализующего интерфейс Serializable. Если класс сериализуется, то сериализуются и подклассы.
Переменные, объявленные как transient не сериализуются, не сериализуются и статические переменные
Интерфейс ObjectOutput - расширяет интерфейсы AutoCloseable, DataOutput, поддерживая сериализацию объектов.
close, flush, write(byte[] buffer), write(byte[] buffer, int смещение, int количество байт), write(int byte), writeObject(Object obj) - записывает объект в вызывающий поток вывода
Класс ObjectOutputStream расширяет OS, и реализует ObjectOutput. Конструктор: OutputSTream stream
+ writeBoolean, writeByte, writeBytes(String str), writeChar, writeChars(String str).. Double,Float, Int, Long, Short
Интерфейс ObjectInput - расширяет интерфейсы AutoCloseable, DataInput, поддерживая сериализацию объектов.
int available - колво бай, доступных в данный момент в буфере ввода; close; read; read(byte[] buffer); read(byte[] buffer, int семещение, int количество байт)
Object readObject - читает объект из вызывающего потока ввода; Long skip(long количество байт) - скипает колво байт, возвращает колво фактически проигнорированных байт
Класс ObjectInputStream расширяет IS и реализует интерфейс ObjectInput. Отвечает за ввод объектов из потока. Конструктор: IS stream
Имеется внутренний класс GetField, упрощащий чтение постоянных полей
+readBoolean, readByte, readChar, readDouble, readFloat, readFully(byte[] buffer), readFully(byte[] buffer, int смещение, int количество байт), readInt, readLong
readObject(может бросить ClassNotFoundException), readShort, readUnsignedByte, readUnsignedShort

15. Что такое Path? Как он реализуется на разных ОС?
Операции на файлом реализуются с помощью статических методов класса Files
Все методы Files, если не принимают кодировку, работают с utf-8
В Files есть метод lines/list/walk, которые возвращают стримы, что м.б. удобно. При этом Stream держит файловый ресурс
соответственно этот метод нужно использовать в блоку try with resources. метод walk обойдет все подкаталоги рекурсивно, но если какой-то каталог не доступен на чтение - бросит исключение
поэтому есть метод walkFileTree

16. Как получить список файлов?
класс File:
	1. Создание объекта класса File:
		File(String путь)
		File(String путь, String name)
		File(File объет_каталога, String name)
		File(URI объект_URI)
	2. Если созданный объект - существует и он - дирректория, то у него можно вызвать метод list(куда можно передать FileNameFilter) 
											и listFiles(куда можно передать FileNameFilter или FileFilter)
	в первом случае получим массив строк, зодержащих полный путь к файлам
	во втором - массив объектов File

	в интрефейсе FilenameFilter определен единственный метод accept(File dir, String file_name), который вызывается каждым файлом из списка.
	в интрефейсе FileFilter  определен единственный метод accept(File path), который вызывается каждым файлом из списка.
класс Files:
метод list

17. Как проверить что файловая сущность является файлом или папкой?
класс File: 1. Создать объект класса файл. 2. метод isFile(); isDirectory()
класс Files: isDirectory, isRegularFile

18. Как удалить файл?
класс File:
	1. Создать объект класса File
	2. boolean delete. (можно так же удалить каталог, если он пуст) 
класс Files:
	1. Создать объект класса Path
	2. delete; deleteIfExists
19. Как переместить файл?
класс File: метод rename, но он плох тем, что может перместить файл в пределах 1ой файловой системы
класс Files: метод move

20. Как управлять аттрибьтами файла?
класс File:
	.setExecutable()
	.setLastModified()
	setReadable()
	.setReadOnly()
	.setWritable()
	
									

21. Как создать файл? 
класс File:

22. Как создать директорию?
класс File:
mkdir() mkdirs()
класс Files: createDirectory, createDirectories

23. Как записать в файл?
класс File:
(BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),"windows-1251"));

try(ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)))
        {
            objectOutputStream.writeObject("String");
        }
класс Files:
write (byte[]; Itreable<String>)
 метод newOutputStream, newByteChannel

24. Как прочитать данные из файла?
класс File:
Если это текстовый файл, то проблемой может быть кодировка, поэтому использую ISReader (куда можно передать кодировку) вместо FileReader 
try(BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "windows-1251")))
Если не текстовый файл -  try(BufferedInputStream reader = new BufferedInputStream((new FileInputStream(file))))
читать можно в буфер byte[] buf = new byte[1024];
            	    int i = reader.read(buf);()
try(DataInputStream reader = new DataInputStream(new BufferedInputStream((new FileInputStream(file)))))
класс Files:
readAllBytes/ readAllLines
метод newBufferedReader, newInputStream,

//try with resources нужен, главным образом, для гарантированного закрытия ресурса + более удобный синтаксис. При не закрытии ресурса могут быть проблемы.
Например если это файл - то в java, это например InputStream, но под ним есть еще объект операционной сиситемы - файловый Дескриптор. Для сбережения ресурурсов,
система ограничивает количество опкрытых файловых дескрипторов. В винде открытый на чтение файл блокируется. Если в файл велась запись, то незакрытие файла означает несброшенные буферы, соответственно информация не дозпаисана.
Всем потокам ввода-вывода соответсвует какое-то число, Файловый дескриптор — это неотрицательное целое число. Когда создается новый поток ввода-вывода, ядро возвращает процессу,
создавшему поток ввода-вывода, его файловый дескриптор.